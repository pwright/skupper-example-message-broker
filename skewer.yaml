title: Accessing a message broker using Skupper
subtitle: |-
  Use [Skupper](https://skupper.io/) to consume from a job queue in a
  private datacenter and process jobs in the public cloud
overview: |-
  This example is a multi-service messaging application that can
  be deployed across multiple Kubernetes clusters using Skupper.

  It contains three services:

  * A message broker running in a private data center.  The broker has
    a queue named "jobs" and a queue named "results".

  * A job requestor running in the private data center.  It serves a
    REST API for submitting jobs and getting the results.

  * A job processor running in the public cloud.  It receives from the
    job queue, does some work, and sends the result to the result
    queue.
prerequisites: |-
  * The `kubectl` command-line tool, version 1.15 or later
    ([installation guide][install-kubectl])

  * The `skupper` command-line tool, the latest version ([installation
    guide][install-skupper])

  * Access to two Kubernetes namespaces, from any providers you
    choose, on any clusters you choose

  [install-kubectl]: https://kubernetes.io/docs/tasks/tools/install-kubectl/
  [install-skupper]: https://skupper.io/start/index.html#step-1-install-the-skupper-command-line-tool-in-your-environment
contexts:
  datacenter:
    kubeconfig: ~/.kube/config-datacenter
    namespace: datacenter
  cloud:
    kubeconfig: ~/.kube/config-cloud
    namespace: cloud
steps:
  - title: Configure separate console sessions
    preamble: |-
      Skupper is designed for use with multiple namespaces, typically on
      different clusters.  The `skupper` command uses your
      [kubeconfig][kubeconfig] and current context to select the namespace
      where it operates.

      [kubeconfig]: https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/

      Your kubeconfig is stored in a file in your home directory.  The
      `skupper` and `kubectl` commands use the `KUBECONFIG` environment
      variable to locate it.

      A single kubeconfig supports only one active context per user.
      Since you will be using multiple contexts at once in this
      exercise, you need to create distinct kubeconfigs.

      Start a console session for each of your namespaces.  Set the
      `KUBECONFIG` environment variable to a different path in each
      session.
    commands:
      cloud:
        - run: export KUBECONFIG=~/.kube/config-cloud
      datacenter:
        - run: export KUBECONFIG=~/.kube/config-datacenter
  - title: Log in to your clusters
    preamble: |-
      The methods for logging in vary by Kubernetes provider.  Find
      the instructions for your chosen providers and use them to
      authenticate and establish access for each console session.  See
      the following links for more information:

      * [Minikube](https://skupper.io/start/minikube.html#logging-in)
      * [Amazon Elastic Kubernetes Service (EKS)](https://docs.aws.amazon.com/eks/latest/userguide/create-kubeconfig.html)
      * [Azure Kubernetes Service (AKS)](https://docs.microsoft.com/en-us/azure/aks/kubernetes-walkthrough#connect-to-the-cluster)
      * [Google Kubernetes Engine (GKE)](https://skupper.io/start/gke.html#logging-in)
      * [IBM Kubernetes Service](https://skupper.io/start/ibmks.html#logging-in)
      * [OpenShift](https://skupper.io/start/openshift.html#logging-in)
  - title: Set the current namespaces
    preamble: |-
      Use `kubectl create namespace` to create the namespaces you wish
      to use (or use existing namespaces).  Use `kubectl config
      set-context` to set the current namespace for each session.
    commands:
      cloud:
        - run: kubectl create namespace cloud
        - run: kubectl config set-context --current --namespace cloud
      datacenter:
        - run: kubectl create namespace datacenter
        - run: kubectl config set-context --current --namespace datacenter
  - title: Install Skupper in your namespaces
    preamble: |-
      The `skupper init` command installs the Skupper router and
      service controller in the current namespace.  Run the `skupper
      init` command in each namespace.

      [minikube-tunnel]: https://skupper.io/start/minikube.html#running-minikube-tunnel

      **Note:** If you are using Minikube, [you need to start
      `minikube tunnel`][minikube-tunnel] before you install Skupper.
    commands:
      cloud:
        - run: skupper init
          await: [deployment/skupper-service-controller, deployment/skupper-router]
      datacenter:
        - run: skupper init --ingress none
          await: [deployment/skupper-service-controller, deployment/skupper-router]
  - title: Link your namespaces
    preamble: |-
      Creating a link requires use of two `skupper` commands in
      conjunction, `skupper token create` and
      `skupper link create`.

      The `skupper token create` command generates a secret token that
      signifies permission to create a link.  The token also carries
      the link details.  The `skupper link create` command then uses
      the link token to create a link to the namespace that generated
      it.

      **Note:** The link token is truly a *secret*.  Anyone who has
      the token can link to your namespace.  Make sure that only those
      you trust have access to it.
    commands:
      cloud:
        - run: skupper token create ~/cloud.token
      datacenter:
        - run: skupper link create ~/cloud.token
        - run: skupper link status --wait 30
  - title: Deploy your services
    commands:
      cloud:
        - run: kubectl create deployment job-processor --image quay.io/skupper/job-processor
          await: [deployment/job-processor]
      datacenter:
        - run: kubectl apply -f message-broker.yaml
          await: [deployment/message-broker]
        - run: kubectl create deployment job-requestor --image quay.io/skupper/job-requestor
          await: [deployment/job-requestor]
  - title: Expose your services
    commands:
      datacenter:
        - run: skupper expose deployment/message-broker --port 5672
          sleep: 10
        - run: kubectl expose deployment/job-requestor --port 8080 --type LoadBalancer
          sleep: 10
  - title: Test your application
    commands:
      datacenter:
        - run: "curl -d text=hello $(kubectl get service/job-requestor -o jsonpath='http://{.status.loadBalancer.ingress[0].ip}:8080/submit-job')"
          sleep: 2
